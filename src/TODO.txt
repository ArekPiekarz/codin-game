plan of actions:

- find a brewable recipe
    if it is found, brew it
    if not, go to next step
- find a recipe closest to the inventory state
- set the start state (current inventory) and the desired state (to have enough ingredients for the recipe)
- set the current node at the desired state
- find all possible actions leading to it
- for each of them score them how far they are from the desired state and how far from the start state
- set the node with the best score as current
    if the current node is the start node, find route to the end by searching for nodes with the smallest cost of path
    if not, go two steps above

Actions: 9
0) action: Action { id: 44, kind: "BREW", deltas: [0, -4, 0, 0], price: 8, castable: false }
1) action: Action { id: 72, kind: "BREW", deltas: [0, -2, -2, -2], price: 19, castable: false }
2) action: Action { id: 48, kind: "BREW", deltas: [0, -2, -2, 0], price: 10, castable: false }
3) action: Action { id: 71, kind: "BREW", deltas: [-2, 0, -2, -2], price: 17, castable: false }
4) action: Action { id: 45, kind: "BREW", deltas: [-2, 0, -2, 0], price: 8, castable: false }
5) action: Action { id: 78, kind: "CAST", deltas: [2, 0, 0, 0], price: 0, castable: true }
6) action: Action { id: 79, kind: "CAST", deltas: [-1, 1, 0, 0], price: 0, castable: true }
7) action: Action { id: 80, kind: "CAST", deltas: [0, -1, 1, 0], price: 0, castable: true }
8) action: Action { id: 81, kind: "CAST", deltas: [0, 0, -1, 1], price: 0, castable: true }

inventory: Inventory { ingredients: [3, 0, 0, 0], score: 0 }

the closest recipe is: 4) action: Action { id: 45, kind: "BREW", deltas: [-2, 0, -2, 0], price: 8, castable: false }
the plan to achieve it should be:

start: [3, 0, 0, 0], desired: [AtLeast(2), _, AtLeast(2), _]
perform 6) action: Action { id: 79, kind: "CAST", deltas: [-1, 1, 0, 0], price: 0, castable: true }
    state after: [2, 1, 0, 0], exhausted spells: [79]
perform 7) action: Action { id: 80, kind: "CAST", deltas: [0, -1, 1, 0], price: 0, castable: true }
    state after: [2, 0, 1, 0], exhausted spells: [79, 80]
rest
    state after: [2, 0, 1, 0], exhausted spells: []
perform 6) action: Action { id: 79, kind: "CAST", deltas: [-1, 1, 0, 0], price: 0, castable: true }
    state after: [1, 1, 1, 0]
perform 7) action: Action { id: 80, kind: "CAST", deltas: [0, -1, 1, 0], price: 0, castable: true }
    state after: [1, 0, 2, 0]
perform 5) action: Action { id: 78, kind: "CAST", deltas: [2, 0, 0, 0], price: 0, castable: true }
    state after: [3, 0, 2, 0]

after that:
4) action: Action { id: 45, kind: "BREW", deltas: [-2, 0, -2, 0], price: 8, castable: false }

ALGORITHM SIMULATION:
desired state: [AtLeast(2), AtLeast(0), AtLeast(2), AtLeast(0)]
perform 5) action: Action { id: 78, kind: "CAST", deltas: [2, 0, 0, 0], price: 0, castable: true }
    provides: deltas: [2, 0, 0, 0], exhausted: 5
    requires: castable 5
    state before: [AtLeast(0), AtLeast(0), AtLeast(2), AtLeast(0)]
perform 7) action: Action { id: 80, kind: "CAST", deltas: [0, -1, 1, 0], price: 0, castable: true }

    state before: [AtLeast(0), AtLeast(1), AtLeast(1), AtLeast(0)], exhausted: [6]
perform 6) action: Action { id: 79, kind: "CAST", deltas: [-1, 1, 0, 0], price: 0, castable: true }
    state before: [AtLeast(1), AtLeast(0), AtLeast(1), AtLeast(0)]
rest
    requires: exhausted non empty
    provides: exhausted: []
perform 7) action: Action { id: 80, kind: "CAST", deltas: [0, -1, 1, 0], price: 0, castable: true }
    provides: exhausted 80
    state before: [AtLeast(1), AtLeast(1), AtLeast(0), AtLeast(0)]
perform 6) action: Action { id: 79, kind: "CAST", deltas: [-1, 1, 0, 0], price: 0, castable: true }
    state before: [AtLeast(2), AtLeast(0), AtLeast(0), AtLeast(0)]

does the algorithm need to go from the end to start?
let's begin at the start
